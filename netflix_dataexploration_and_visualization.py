# -*- coding: utf-8 -*-
"""Netflix DataExploration and Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18yM6jhKOL2okdB2zVFXoXokgPsdmQjSh

# Business Case: Netflix - Data Exploration and Visualisation
![Netflix.png](data:image/png;base64,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)

#About Netflix ðŸ¿

Netflix is one of the most popular media and video streaming platforms. They have over 10000 movies or tv shows available on their platform, as of mid-2021, they have over 222M Subscribers globally. This tabular dataset consists of listings of all the movies and tv shows available on Netflix, along with details such as - cast, directors, ratings, release year, duration, etc.

In this notebook, I'll give an Exploratory Data Analysis of the Netflix dataset. We will explore the data and hopefully bring some insights.

Dataset:https://d2beiqkhq929f0.cloudfront.net/public_assets/assets/000/000/940/original/netflix.csv
"""

#Download Data set
!gdown https://d2beiqkhq929f0.cloudfront.net/public_assets/assets/000/000/940/original/netflix.csv

"""**Importing Libraries and Loading the Dataset**"""

# Import Relevant Packages
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import missingno as msno
# import warnings
# warnings.filterwarnings('ignore')
import copy
from wordcloud import WordCloud

# Load Data set
df = pd.read_csv('netflix.csv')

"""**Basic Data Exploration**"""

#First 5 Rows Data
df.head()

#Last 5 Rows Data
df.tail()

# Columns
df.columns

"""In this dataset we have

- Type identifier; Movie or Tv Show
- Titles
- Directors
- Cast
- Actors
- Country where the Movie or Tv Show was produced
- Date it was added on Netflix
- Actual Release year of the Content
- Ratings
- Total Duration - in minutes or number of seasons
- listed_in
- Description
"""

#Data Set Shape
df.shape

# Data types in columns
df.info()

"""ðŸª•**Insights**


From the above analysis, it is clear that, data has total of 12 features with lots of mixed alpha numeric data. Also we can see missing data in 5 of the total columns.

**ðŸ“ Statistical Summary**
"""

df.describe()

df['type'].value_counts()

df['director'].value_counts().head()

df['cast'].value_counts().head()

df['country'].value_counts().head()

df['date_added'].value_counts().head()

df['rating'].value_counts().head()

df['listed_in'].nunique()

"""**ðŸª• Insights**

**1. Type of content**- Among the 8807 items available on Netflix, 6131 of them are movies, accounting for nearly 70% of the total content. The remaining 30% consists of TV series.

**2. Director**- Rajiv Chilaka holds the top position on the director list, with 19 credits to his name.

**3. Cast**- David Attenborough leads the actor list with 19 appearances in various films and shows on Netflix.

**4. Country**- The USA ranks at the top as the country with the highest production contribution to Netflix, accounting for 35% of the total content.

**5. Date Added**- January 1, 2020, stands out as the peak date for content uploads on Netflix. On that day alone, approximately 109 different shows and movies were added to the platform.

**6.Ratings**- There are 17 different types of ratings present on Netflix. The "TV-MA" (Mature Audience Only) rating dominates the charts, covering almost 36% of the total shows and movies on the platform with this rating.


**7. Genre**- Among the 8807 items available on Netflix, 514 unique genre are listed in the given data.

**ðŸ‘¥ Duplicate Detection**
"""

df.duplicated().value_counts()

"""**ðŸª• Insights**

There are no duplicate entries in the dataset.
"""

# checking the value_counts for columns
for i in ['type','release_year','rating','duration']:
    print('Unique Values in',i,'column are :-')
    print(df[i].unique())
    print('-'*70)

# checking the value_counts for columns
for i in ['type','release_year','rating','duration']:
    print('Value count in',i,'column are :-')
    print(df[i].value_counts())
    print('-'*70)

"""**ðŸª• Insights**

There is presense of 3 unusual values in rating column.

**ðŸ‘¨ðŸ½â€ðŸ’» Missing Value Analysis**
"""

df.isnull().sum()

print("percentage of nullity: ")
for i in df.columns:
    null_rate = df[i].isnull().sum()/df.shape[0] * 100
    if null_rate > 0:
        print(f"{i}'s null rate : {round(null_rate,2)}%")

# missing value visualisation
color = ['#5E40BE','#5E40BE','#5E40BE','#5E40BE','#5E40BE','#5E40BE','#E50914','#E50914','#E50914','#E50914','#E50914','#E50914']
ax = msno.bar(df,sort = 'descending',color = color,fontsize = 20)
ax.text(3.5,1.2,'Visualization of Dataset Nullity',{'font':'serif', 'color':'black','weight':'bold','size':30})
plt.show()

"""**ðŸª• Insights**

From our above analysis, there are total of 6 columns containing missing values. Director's column has the most missing values followed by cast and country column. Date added, ratings and duration have significantly less missing values (<1%).

**ðŸ“ Approach to fill missing values**


**1. Director Column** - Filling it with Unknown Director.

**2. Cast Column** - Filling it with Unknown Cast.

**3. Country Column** - Filling it with Unknown Country

**4. Date Added Column** - Since it had only 10 missing values, details about it were found from Google. Following details were obtained -



*   A Young Doctor's Notebook and Other Stories - September 15, 2014
* Anthony Bourdain: Parts Unknown - June 1, 2020
* Frasier - April 1, 2015
* Friends - January 1, 2015
* Gunslinger Girl - January 4, 2016
* Kikoriki - July 6, 2017
* La Familia P. Luche - June 1, 2015
* Maron - November 2, 2018
* Red vs. Blue - March 21, 2015
* The Adventures of Figaro Pho - January 1, 2016

**5. Rating Column** - Since it had only 7 missing values, details about it were found from Google. Following details were obtained -

* 13TH: A Conversation with Oprah Winfrey & Ava ... - TV-PG
* Gargantia on the Verdurous Planet - TV-PG
* Little Lunch - TV-Y
* My Honor Was Loyalty - PG-13
* Louis C.K. 2017 - TV-MA
* Louis C.K.: Hilarious - TV-MA
* Louis C.K.: Live at the Comedy Store - TV-MA

**5. Duration Column** - Since it had only 3 missing values, details about it were found from Google. Following details were obtained -

* Louis C.K. 2017 - 74 min
* Louis C.K.: Hilarious - 83 min
* Louis C.K.: Live at the Comedy Store - 65 min

**ðŸ” Replacing the missing values**
"""

df['date_added']

df.fillna({'director':'Unknown director'},inplace = True)
df.fillna({'cast':'Unknown cast'},inplace = True)
df.fillna({'country':'Unknown country'},inplace = True)

date = {"A Young Doctor's Notebook and Other Stories" : 'September 15, 2014',
       "Anthony Bourdain: Parts Unknown" : 'June 1, 2020',
        "Frasier" : 'April 1, 2015',
        "Friends" : 'January 1, 2015',
        "Gunslinger Girl" : 'January 4, 2016',
        "Kikoriki" : 'July 6, 2017',
        "La Familia P. Luche" : 'June 1, 2015',
        "Maron" : 'November 2, 2018',
        "Red vs. Blue" : 'March 21, 2015',
        "The Adventures of Figaro Pho": 'January 1, 2016'}

for i in date :
    df.loc[df['title'] == i, 'date_added'] = date[i]

ratings = {"13TH: A Conversation with Oprah Winfrey & Ava DuVernay" : 'TV-PG',
         "Gargantia on the Verdurous Planet" : 'TV-PG',
          "Little Lunch" : 'TV-Y',
          "My Honor Was Loyalty" : 'PG-13',
          "Louis C.K. 2017" : 'TV-MA',
          "Louis C.K.: Hilarious" : 'TV-MA',
          "Louis C.K.: Live at the Comedy Store":'TV-MA'}

for i in ratings:
    df.loc[df['title'] == i,'rating'] = ratings[i]

durn = {"Louis C.K. 2017" : '74 min',
          "Louis C.K.: Hilarious" : '83 min',
          "Louis C.K.: Live at the Comedy Store":'65 min'}

for i in durn:
    df.loc[df['title'] == i,'duration'] = durn[i]

# check
df.isnull().sum()

"""**Adding new columns for better analysis**

We will add 3 columns - year_added,month_added,week_added to the df to facilitate further data analysis.
"""

# converting date_added to datetime column
df['date_added'] = pd.to_datetime(df['date_added'],errors='coerce')

#adding new columns
df['year_added'] = df['date_added'].dt.year
df['month_added'] = df['date_added'].dt.month_name()
df['week_added'] = df['date_added'].dt.isocalendar().week

df.head(3)

"""**Un-nesting the columns for better analysis**

We will create a new df which has un-nested director,cast and country columns into multiple rows which will help while doing analysis related to them.
"""

# creating a separate table
df1 = copy.deepcopy(df)


df1["director"] = df["director"].str.split(", ")
df1["cast"] = df["cast"].str.split(", ")
df1["country"] = df["country"].str.split(", ")

df1 = df1.explode(['director'])
df1 = df1.explode(['cast'])
df1 = df1.explode(['country'])
df1.head(3)

#checking shape of new df
df1.shape

"""# ***ðŸ“ˆData Visualisation***

**ðŸŽ¬ Content Distribution**
"""

x = df['type'].value_counts()
x

#setting the plot style
fig = plt.figure(figsize = (12,5))
f_gs = fig.add_gridspec(2,2)

# creating graph for count of movies
ax0 = fig.add_subplot(f_gs[:,0])
ax0.bar(x.index,x.values,color =['#21134D','#F5921B'],zorder = 2,width = 0.5)
ax0.set(ylabel = 'Count')
ax0.set(xlabel = 'Type')

# adding value_count label
ax0.text(-0.1,3000,x.values[0],fontsize=15, fontweight='light', fontfamily='serif',color='white')
ax0.text(0.9,1400,x.values[1],fontsize=15, fontweight='light', fontfamily='serif',color='white')


# removing the axis lines
for s in ['top', 'right']:
    ax0.spines[s].set_visible(False)

# creating the visual for percentage distribution
ax1 = fig.add_subplot(f_gs[0,1])
ax1.barh(x.index[0],0.7,color = '#21134D')
ax1.barh(x.index[0],0.3,left = 0.7,color = '#F5921B')
ax1.set(xlim = (0,1))

#removing the axis info
ax1.set_xticks([])
ax1.set_yticks([])

# adding graph info
ax1.text(0.35,0.04,'70%',va = 'center', ha='center',fontsize=35, fontweight='light', fontfamily='serif',color='white')
ax1.text(0.35,-0.2,'Movie',va = 'center', ha='center',fontsize=15, fontweight='light', fontfamily='serif',color='white')
ax1.text(0.85,0.04,'30%',va = 'center', ha='center',fontsize=35, fontweight='light', fontfamily='serif',color='white')
ax1.text(0.85,-0.2,'TV Show',va = 'center', ha='center',fontsize=15, fontweight='light', fontfamily='serif',color='white')

#removing the axis lines
for s in ['top', 'left', 'right', 'bottom']:
    ax1.spines[s].set_visible(False)

# adding text insight
ax2 = fig.add_subplot(f_gs[1,1])
ax2.set_facecolor('#f6f5f5')
ax2.set_xticks([])
ax2.set_yticks([])

ax2.text(0.1,0.5,'Netflix focuses on\nproducing a higher quantity\nof Movies compared to TV shows.',
         va = 'center', ha='left',fontsize=15, fontweight='light', fontfamily='serif',color='black')

#adding title to the visual
fig.suptitle('Netflix Content Distribution',fontproperties = {'family':'serif', 'size':15,'weight':'bold'})

plt.show()

"""# **â™ˆEvolution of Netflix's Growing Library of Movies & TV Shows**

**Analysis of number of Movies and TV shows added over time on Netflix**


"""

#setting the plot style
fig,ax = plt.subplots(figsize = (12,6))
color = ['#21134D','#F5921B']

#plotting the visual
for i,type_ in  enumerate(df['type'].unique()):
    temp_df = df.loc[df['type'] == type_,'year_added'].value_counts().sort_index()
    ax.plot(temp_df.index,temp_df.values,color = color[i],label = type_)
    ax.fill_between(temp_df.index,0,temp_df.values,color = color[i])

#changing the y-axis position from left to right
ax.yaxis.tick_right()

#removing the axis lines
for s in ['top','left']:
    ax.spines[s].set_visible(False)

#adding title to the visual
ax.set_title('Number of Movies & TV Shows added over time',
            {'font':'serif', 'size':15,'weight':'bold'})


#adding custom legend
ax.text(2008,200,"Movie", fontweight="bold", fontfamily='serif', fontsize=15, color='#21134D')
ax.text(2009.4,200,"|", fontweight="bold", fontfamily='serif', fontsize=15, color='black')
ax.text(2009.7,200,"TV Show", fontweight="bold", fontfamily='serif', fontsize=15, color='#F5921B')
plt.legend(loc = (0.04,0.09),ncol = 2)


plt.show()

"""**ðŸ” Insights**

* We see a slow start for Netflix over several years. Things begin to pick up in 2015 and then there is a rapid increase from 2016.

* As we saw in the timeline at the start of this analysis, Netflix went global in 2016 - and it is extremely noticeable in this plot.

**ðŸŽ¥Directors with the Most Appearances**

* **Top 10 directors** who have appeared in most movies or TV shows.
"""

d_cnt = df1.groupby('director')['title'].nunique().sort_values(ascending  = False)[0:11].reset_index()
d_cnt

# droping unknown director and reversing the df
d_cnt = d_cnt.iloc[-1:-11:-1]

#setting the plot style
fig,ax = plt.subplots(figsize = (10,6))

#creating the plot
ax.barh(y = d_cnt['director'],width = d_cnt['title'],height = 0.2,color = '#003366')
ax.scatter(y = d_cnt['director'], x = d_cnt['title'] , s = 200 , color = '#003366' )

#removing x-axis
ax.set_xticks([])

#adding label to each bar
for y,x in zip(d_cnt['director'],d_cnt['title']):
    ax.text( x + 0.5 , y , x,{'font':'serif', 'size':10,'weight':'bold'},va='center')

#removing the axis lines
for s in ['top','bottom','right']:
    ax.spines[s].set_visible(False)

#creating the title
ax.set_title('Top 10 Directors with the Most Appearances on Netflix',
                {'font':'serif', 'size':15,'weight':'bold'})

plt.show()

"""**ðŸ‘¨ðŸ½â€ðŸŽ¤Actor's with the Most Appearances**

* **Top 10 Actor's** who have appeared in most movies or TV shows.
"""

a_cnt = df1.groupby('cast')['title'].nunique().sort_values(ascending  = False)[0:11].reset_index()

a_cnt

# droping unknown actor and reversing the list
a_cnt = a_cnt.iloc[-1:-11:-1]

#setting the plot style
fig,ax = plt.subplots(figsize = (10,6))

#creating the plot
ax.barh(y = a_cnt['cast'],width = a_cnt['title'],height = 0.2,color = '#003366')
ax.scatter(y = a_cnt['cast'], x = a_cnt['title'] , s = 200 , color = '#003366' )

#removing x-axis
ax.set_xticks([])

#adding label to each bar
for y,x in zip(a_cnt['cast'],a_cnt['title']):
    ax.text( x + 0.7 , y , x,{'font':'serif', 'size':10,'weight':'bold'},va='center')

#removing the axis lines
for s in ['top','bottom','right']:
    ax.spines[s].set_visible(False)

#creating the title
ax.set_title('Top 10 Actors/Cast with the Most Appearances on Netflix',
            {'font':'serif', 'size':15,'weight':'bold'})

plt.show()

"""**ðŸ” Insights**
* Significantly, 8 out of the top 10 Actors/Cast with the highest number of appearances on Netflix are of Indian origin

**ðŸŒ Global Streaming**

* **Top 10 Countries** which have produced the most Movies and most TV Shows on Netflix.
"""

#creating df for top 10 movies producing countries
df_movie = df1[df1['type'] == 'Movie']
df_movie = df_movie.groupby('country')['title'].nunique().sort_values(ascending = False).reset_index().loc[0:10]
df_movie = df_movie.drop(3)

#replacing country names in shortformat
df_movie['country'] = df_movie['country'].replace({'United States':'USA','United Kingdom':'UK','South Korea':'S korea'})
df_movie

#setting the plot style
fig,ax = plt.subplots(figsize = (13,6))

color_map = ['#F5921B' for i in range(10)]
color_map[0] = color_map[1] = color_map[2] = '#21134D'

#creating the plot
ax.bar(df_movie['country'],df_movie['title'],color = color_map,zorder = 2)

#adding valuecounts
for i in df_movie.index:
    ax.text(df_movie.loc[i,'country'],df_movie.loc[i,'title'] + 75, df_movie.loc[i,'title'],
           {'font':'serif', 'size':10},ha = 'center',va = 'center')

#removing the axis lines
for s in ['top','right']:
    ax.spines[s].set_visible(False)

#adding title to the visual
ax.set_title('Top 10 Movie Producing Countries on Netflix',
            {'font':'serif', 'size':15,'weight':'bold'})

plt.show()

#creating df for top 10 tv shows producing countries
df_tv = df1[df1['type'] == 'TV Show']
df_tv = df_tv.groupby('country')['title'].nunique().sort_values(ascending = False).reset_index().loc[0:10]

#dropping unknown country column
df_tv = df_tv.drop(1)

#replacing country names in shortformat
df_tv['country'] = df_tv['country'].replace({'United States':'USA','United Kingdom':'UK','South Korea':'S korea'})
df_tv

#setting the plot style
fig,ax = plt.subplots(figsize = (13,6))

color_map = ['#F5921B' for i in range(10)]
color_map[0] = color_map[1] = color_map[2] = '#21134D'

#creating the plot
ax.bar(df_tv['country'],df_tv['title'],color = color_map,zorder = 2)

#adding valuecounts
for i in df_tv.index:
    ax.text(df_tv.loc[i,'country'],df_tv.loc[i,'title'] + 25, df_tv.loc[i,'title'],
           {'font':'serif', 'size':10},ha = 'center',va = 'center')

#removing the axis lines
for s in ['top','right']:
    ax.spines[s].set_visible(False)

#adding title to the visual
ax.set_title('Top 10 TV Shows Producing Countries on Netflix',
            {'font':'serif', 'size':15,'weight':'bold'})

plt.show()

"""**ðŸ” Insights**
* Netflix heavily invests in content production in the USA, its home country, to attract and retain subscribers. India, being the second on the list, signifies Netflix's strategic focus on the Indian market due to its significant population and growing demand for streaming services.

* Indian's prefer to watch movies over TV shows, on contrary South koreans perfer Tv shows over movies.

#**ðŸŽ¥ ðŸ†š ðŸ“º Content Split**
* Content split for Top 10 Countries which have produced the most Movies and most TV Shows on Netflix.
"""

#creating a df for top 10 countries based on overall content count
c_cnt = df1.groupby('country')['title'].nunique().sort_values(ascending  = False).reset_index().loc[0:10]

c_cnt = c_cnt.drop(2) #dropping unknown country column

#renaming the countries
c_cnt['country'] = c_cnt['country'].replace({'United States':'USA','United Kingdom':'UK','South Korea':'S korea'})
c_cnt

#creating a df to calculate split between tv-show and movies
df_merge = pd.merge(c_cnt,df_movie, on = 'country', how = 'left')
df_merge = pd.merge(df_merge,df_tv, on = 'country',how = 'left')

#renaming the columns
df_merge.rename(columns = {'title_x':'Total_Count','title_y':'Movie_Count','title':'TV_Show_Count'},inplace = True)

#filling the uncaptured information
df_merge.fillna({'Movie_Count': df_merge['Total_Count']-df_merge['TV_Show_Count']},inplace = True)
df_merge.fillna({'TV_Show_Count': df_merge['Total_Count']-df_merge['Movie_Count']},inplace = True)

#calculating the %split between movies and tv-shows
df_merge['Movie%'] = round((df_merge['Movie_Count']/df_merge['Total_Count'])*100)
df_merge['TV%'] = round((df_merge['TV_Show_Count']/df_merge['Total_Count'])*100)

#changing the data-type of columns to int
for i in df_merge.columns[1:]:
    df_merge[i] = df_merge[i].astype('int')

#sorting the df
df_merge = df_merge.sort_values(by= 'Movie%')
df_merge

#setting the plot style
fig,ax = plt.subplots(figsize = (13,8))

#plotting the visual
ax.barh(df_merge['country'],width = df_merge['Movie%'],color = '#21134D')
ax.barh(df_merge['country'],width = df_merge['TV%'],left = df_merge['Movie%'],color ='#F5921B')
ax.set(xlim=(0,100))

#adding % values in the bars

for i in df_merge.index:
    ax.text((df_merge.loc[i,'Movie%'])/2,df_merge.loc[i,'country'],f"{df_merge.loc[i,'Movie%']}%",
            va = 'center', ha='center',fontsize=15, fontweight='light', fontfamily='serif',color='white')

    ax.text((df_merge.loc[i,'Movie%'] + (df_merge.loc[i,'TV%']/2)),df_merge.loc[i,'country'],f"{df_merge.loc[i,'TV%']}%",
            va = 'center', ha='center',fontsize=15, fontweight='light', fontfamily='serif',color='white')

#removing the axis lines

for s in ['top','right','bottom']:
    ax.spines[s].set_visible(False)

#adding title to the visual
ax.set_title('Top 10 Countries Movie & TV Show split',
            {'font':'serif', 'size':15,'weight':'bold'})

#adding legend
ax.legend(['Movie','TV Show'],loc = (0.75,1),ncol = 2,fontsize = 10)

plt.show()

"""**ðŸ” Insights**

* **TV shows are more popular** than movies in **Asian countries**, especially South Korea and Japan, where they account for **more than 60%** of the content.

* **Movies** are more popular than **TV shows** in **European countries**,where they account for more than 65% of the content.

* **India** has the **highest percentage of movies (92%)** among all the countries, which may indicate a high demand for movies.

**ðŸ“… Best Month to launch a TV show/Movie?**
"""

month = df.groupby('month_added')['type'].value_counts()
month.name = 'count' # to avoid error while doing reset_index
month = month.reset_index()

#converting month_added to categorical type to help in future sorting steps
months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
month['month_added'] = pd.Categorical(month['month_added'], categories=months, ordered=True)

month.head()

# creating two different tables for movies and tv shows
month_movie = month.loc[month['type'] == 'Movie'].sort_values(by = 'month_added')
month_tv = month.loc[month['type'] == 'TV Show'].sort_values(by = 'month_added')

#setting the plot style
fig,ax = plt.subplots(figsize = (13,6))
ax.set_facecolor('#f6f5f5')

#creating the plot
sns.lineplot(data = month_movie, x = 'month_added', y = 'count',marker = 'o',markersize = 10,color ='#21134D',
             label = 'Movie',ax = ax)
sns.lineplot(data = month_tv, x = 'month_added', y = 'count',marker = 'o',markersize = 10,color ='#F5921B',
             label = 'TV Show', ax = ax)


#customizing axis label
plt.xlabel(None)

#customizing legend
plt.legend(loc = 'center right')

#creating the title
ax.set_title('Best Month to launch a TV show/Movie?',
            {'font':'serif', 'size':15,'weight':'bold'})

plt.show()

"""**ðŸ” Insights**


* The monthly upload count of both Movies and TV shows exhibits a remarkably **similar trend**.

* The months of **July, August, October, and December** record higher content upload counts, whereas **February, May, and November** experience comparatively lower counts.

**ðŸŽ¯ Target Audience**

**Target Audience distribution** for Movies and TV shows on Netflix
"""

movie_rating = df.loc[df['type'] == 'Movie','rating'].value_counts().reset_index()
tv_rating = df.loc[df['type'] == 'TV Show','rating'].value_counts().reset_index()

#function for binning age groups
def age_group(x):
    if x in ['TV-Y', 'TV-G', 'G']:
        return 'Little Kids'
    elif x in ['TV-Y7', 'TV-Y7-FV', 'TV-PG', 'PG']:
        return 'Older Kids'
    elif x in ['PG-13','TV-14']:
        return 'Teens'
    else:
        return 'Adults'

#creating a df for binning the age groups
#binning ratings into age groups for movies
movie_rating['age'] = movie_rating['rating'].apply(lambda x:age_group(x))
age_m_rating = movie_rating.groupby('age')['count'].sum().sort_values(ascending = False).reset_index()

#binning ratings into age groups for tv shows
tv_rating['age'] = tv_rating['rating'].apply(lambda x:age_group(x))
age_t_rating = tv_rating.groupby('age')['count'].sum().reset_index()

age_m_rating

#setting the plot style
fig = plt.figure(figsize = (10,5.5))
gs = fig.add_gridspec(1,2)

# creating pie chart for movies
ax0 = fig.add_subplot(gs[0,0])

color_map = ['LightCoral','Salmon','DarkSalmon','LightSalmon']
ax0.pie(age_m_rating['count'],labels = age_m_rating['age'],autopct = '%.1f%%',shadow = True,colors = color_map,
        explode = [0.1,0,0,0],wedgeprops = {'linewidth': 5},textprops={'fontsize': 13, 'color': 'black'})

#setting title for visual
ax0.set_title('Movies Vs Audience Age Group',
            {'font':'serif', 'size':15,'weight':'bold'})

# creating pie chart for tvshows
ax1 = fig.add_subplot(gs[0,1])

color_map = ['LightCoral','Salmon','DarkSalmon','LightSalmon']
ax1.pie(age_t_rating['count'],labels = age_t_rating['age'],autopct = '%.1f%%',shadow = True,colors = color_map,
        explode = [0.1,0,0,0],wedgeprops = {'linewidth': 5},textprops={'fontsize': 13, 'color': 'black'})

#setting title for visual
ax1.set_title('TV Shows Vs Audience Age Group',
            {'font':'serif', 'size':15,'weight':'bold'})

#setting overall title
fig.suptitle('Netflix Target Audience Analysis',fontproperties = {'family':'serif', 'size':15,'weight':'bold'})

plt.show()

"""**ðŸ” Insights**
1. Movies
 * Roughly half of the films available on the platform cater to adult audiences, while around 30% of the overall content is designed for teenagers, and the remaining 20% is tailored for children
2. TV Shows

 * The pattern holds true for television shows as well. The only distinction is that 30% of the content is targeted towards children, which signifies the inclusion of anime shows within Netflix's offerings.

**ðŸ§’ðŸ»ðŸ‘¨ðŸ»ðŸ‘´ðŸ» Netfilx Age Demographics Across Geographies**

* **Age Group Distribution** Across Countries for Movies and TV shows on Netflix
"""

#function for binning age groups
def age_group(x):
    if x in ['TV-Y', 'TV-G', 'G']:
        return 'Little Kids'
    elif x in ['TV-Y7', 'TV-Y7-FV', 'TV-PG', 'PG']:
        return 'Older Kids'
    elif x in ['PG-13','TV-14']:
        return 'Teens'
    else:
        return 'Adults'

#creating a new col for age groups
df1['age_group'] = df1['rating'].apply(lambda x:age_group(x))

#creating a df for top 10 countries based on overall content count
c_cnt = df1.groupby('country')['title'].nunique().sort_values(ascending  = False).reset_index().loc[0:10]

c_cnt = c_cnt.drop(2) #dropping unknown country column

#creating a new df for top 1o countries with target age count
df2 = df1[['country','title','age_group']] #taking relevant columns from the df

df2 = df2[df2['country'].isin(c_cnt['country'])] #filtering top 10 count

df2 = df2.drop_duplicates(keep = 'first') #removing the duplicates to get exact count

df2 = df2.groupby(['country','age_group'])['title'].count().reset_index() #creating the df

df2 = df2.sort_values(by =['country','title'],ascending = [False,False]) #sorting the df

df2 = df2.rename({'title':'count'},axis = 1) #renaming the column

#changing the country names to shortform
df2['country'] = df2['country'].replace({'United States':'USA','United Kingdom':'UK','South Korea':'S korea'})

#adding a new percent column to denote the values in percentage
def percent(x):
    x['percent'] = round(x['count'] / x['count'].sum(),2)
    return x
df2 = df2.groupby('country').apply(lambda x:percent(x))
df2 = df2.sort_values('count',ascending=False)
df2 = df2.reset_index(drop = True)

df2.head(5)

#changing the df shape for making the heatmap
df_heatmap = df2.pivot(index='age_group',columns = 'country',values = 'percent')

#rearranging the df values in decreasing order of overall content count
country_order = ['USA','India','UK','Canada','France','Japan','Spain','S korea','Germany','Mexico']

age_order = ['Little Kids','Older Kids','Teens','Adults']

df_heatmap = df_heatmap.loc[age_order,country_order]

df_heatmap

#setting the plot style
fig,ax = plt.subplots(figsize = (12,12))

#plotting the visual
color = sns.color_palette("dark:#F5921B", as_cmap=True)

sns.heatmap(data = df_heatmap,ax=ax,cmap = color,square = True,linewidth = 2.5,cbar = False,annot = True,fmt = '.0%')

#removing axis labels
ax.set_xlabel('')
ax.set_ylabel('')

#removing tick marks but keeping the labels
ax.tick_params(axis = 'both',length = 0)

#setting title to visual
ax.set_title('Target Ages By Country',{'font':'serif', 'size':15,'weight':'bold'})

plt.show()

"""**ðŸ” Insights**

**1. Teen-Centric Content in India, Japan and S Korea**

 * India and Japan stand out for having a considerably higher percentage of content targeted at "Teens." In Japan the trend continues to Older Kids as well. This suggests that there's a trend towards producing content that appeals to this age group

**2. Adult-Centric Content in Spain, Mexico,Germany and France**

 * Spain,Mexico,Germany and France have relatively high percentages of content aimed at "Adults." This could reflect a cultural inclination towards producing and consuming more mature content in these countries.

**3. Balanced Content in USA,UK and Canada**

 * USA,UK and Canada are closey aligned with their Netflix target ages suggesting a similar preference or taste among these markets.

**ðŸ•šNetflix's Movie and TV Show Runtimes**

* Analysis of runtimes for Movies and TV shows on Netflix
"""

#creating a df for tv show duration count
tv_duration = df.loc[df['type'] == 'TV Show','duration'].value_counts().reset_index()

#binning the seasons with less count for better analysis
tv_duration.replace({'1 Season':'1S',
                    '2 Seasons':'2S to 3S','3 Seasons':'2S to 3S',
                      '4 Seasons':'4S to 6S','5 Seasons':'4S to 6S','6 Seasons':'4S to 6S',
                     '7 Seasons':'7S to 9S','8 Seasons':'7S to 9S','9 Seasons':'7S to 9S',
                    '10 Seasons':'10S to 17S','11 Seasons':'10S to 17S','12 Seasons':'10S to 17S','13 Seasons':'10S to 17S',
                     '14 Seasons':'10S to 17S','15 Seasons':'10S to 17S','16 Seasons':'10S to 17S','17 Seasons':'10S to 17S'},
                    inplace = True)

#grouping the seasons and finding the count
tv_duration = tv_duration.groupby('duration')['count'].sum().sort_values(ascending = False).reset_index()

tv_duration.rename({'index':'Season','duration':'Count'},axis = 1,inplace = True)
tv_duration.columns=['Season','Count']
tv_duration

#creating a df for movie's duration count
movie_duration = df.loc[df['type'] == 'Movie','duration'].value_counts().reset_index()
# movie_duration
#removing 'min' from every entry to help in binning process
movie_duration['duration'] = movie_duration['duration'].str[:-3]

#converting the movie duration entries into integers
movie_duration['duration'] = movie_duration['duration'].astype('int')

#binning the values into categories
bin_range = [0,30,90,150,210,float('inf')]
bin_labels = ['Short Films', 'Medium Films', 'Standard Films', 'Long Films ', 'Epic Films ']

movie_duration['duration'] = pd.cut(movie_duration['duration'],bins = bin_range,labels = bin_labels)

#grouping the different movie types and finding the count
movie_duration = movie_duration.groupby('duration',observed=False)['count'].sum().sort_values(ascending = False,).reset_index()

movie_duration.columns=['Film Length','Count']
movie_duration

#setting the plot style
fig = plt.figure(figsize = (15,7))
gs = fig.add_gridspec(1,2)

# creating visual for movies duration analysis
ax0 = fig.add_subplot(gs[0,0])

ax0.bar(movie_duration['Film Length'],height = movie_duration['Count'],edgecolor='black',color = '#21134D',zorder = 2)

#adding valuecounts
for i in movie_duration.index:
    ax0.text(movie_duration.loc[i,'Film Length'],movie_duration.loc[i,'Count'] + 50, movie_duration.loc[i,'Count'],
           {'font':'serif', 'size':10},ha = 'center',va = 'center')

#removing the axis lines

for s in ['top','right']:
    ax0.spines[s].set_visible(False)


#setting title for visual
ax0.set_title('Movies Duration Analysis',{'font':'serif', 'size':15,'weight':'bold'})

# creating visual for tvshows duration analysis
ax1 = fig.add_subplot(gs[0,1])

color_map = ['lightpink', 'deeppink', 'mediumvioletred', 'darkred', 'firebrick']
ax1.bar(tv_duration['Season'],height = tv_duration['Count'],edgecolor='black',color = '#F5921B',zorder = 2)

#adding valuecounts
for i in tv_duration.index:
    ax1.text(tv_duration.loc[i,'Season'],tv_duration.loc[i,'Count'] + 25, tv_duration.loc[i,'Count'],
           {'font':'serif', 'size':10},ha = 'center',va = 'center')


#removing the axis lines

for s in ['top','right']:
    ax1.spines[s].set_visible(False)

#setting title for visual
ax1.set_title('TV Show Duration Analysis',
            {'font':'serif', 'size':15,'weight':'bold'})

#setting overall title
fig.suptitle('Netflix Content Duration Analysis',fontproperties = {'family':'serif', 'size':15,'weight':'bold'})

plt.show()

"""**ðŸ” Insights**
**1. Movies**

 * The majority of films fall under the "Standard Films" category,indicating that viewers prefer movies that are of typical length for a movie-watching experience.

 * The higher count of "Medium Films" also indicates that viewers are interested in movies that are slightly longer than average, suggesting that movies with a bit more depth and storytelling might be well-received.

 * The presence of "Long Films", "Short Films" and "Epic Films" in the content library indicates that Netflix caters to a wide range of viewer preferences.

**2. TV Shows**

 * TV shows with a single season (1S) are the most common, suggesting that shorter series or limited series are popular on Netflix.
 * As the season duration increases, the count of TV shows decreases. This pattern indicates that viewers might prefer shorter series over longer ones.

#**â²Analysing the time difference**

* Analysing the time difference between release and added years for Movies and TV shows on Netflix
"""

#creating df for top 10 movies producing countries
df_movie = df1[df1['type'] == 'Movie']
df_movie = df_movie.groupby('country')['title'].nunique().sort_values(ascending = False).reset_index().loc[0:10]

#dropping unknown country column
df_movie = df_movie.drop(3)

#creating df with top 10 movie producing countries and average difference between release year and added year
movie_year = df1[(df1['type'] == 'Movie') & (df1['country'].isin(df_movie['country']))]

#adding the difference column
movie_year.loc[:, 'diff'] = movie_year['year_added'] - movie_year['release_year']

#calculating the average diff
movie_year = movie_year.groupby('country')['diff'].mean().round().reset_index().sort_values(by = 'diff',ascending = False)

#converting to int
movie_year['diff'] = movie_year['diff'].astype('int')

movie_year

#creating y-axis co-ordinates
yrange = range(1,len(movie_year)+1)
xrange = [0 for i in range(10)]

#setting the plot style
fig, ax = plt.subplots(figsize=(8, 7))


#plotting the scatter points
ax.scatter(xrange,yrange,color = '#21134D',s=100,label = 'Movie Release')
ax.scatter(movie_year['diff'],yrange,color = '#F5921B',s=100,label = 'Movie Added')

#plotting the horizontal lines between the points
ax.hlines(yrange,xmin = 0,xmax = movie_year['diff'],color = 'grey',alpha = 0.4,label = 'Average Difference')

#adding avg. difference values on lines
for i in range(10):
    ax.text(movie_year['diff'].iloc[i]/2,yrange[i]+0.2,f"{movie_year['diff'].iloc[i]} years",
            {'font':'serif', 'size':9,'fontweight':'light'},ha = 'center',va = 'center')

#removing the axislines
for s in ['top', 'left', 'right', 'bottom']:
    ax.spines[s].set_visible(False)

#removing tick marks but keeping the labels
ax.tick_params(axis = 'both',length = 0)

#customizing the y-axis labels
ax.set_yticks(yrange,movie_year['country'],fontsize= 12,fontfamily='serif',fontweight = 'bold')

#adding xlabel
ax.set_xlabel('Difference in Years',fontfamily='serif',fontsize = 11,fontweight = 'bold')

#Adding title to the graph
ax.set_title('How old are the Movies?',{'font':'serif', 'size':15,'weight':'bold'})

#adding legend
plt.legend(loc = (0.8,0.83))


plt.show()

#creating df for top 10 tv shows producing countries
df_tv = df1[df1['type'] == 'TV Show']
df_tv = df_tv.groupby('country')['title'].nunique().sort_values(ascending = False).reset_index().loc[0:10]

#dropping unknown country column
df_tv = df_tv.drop(1)

#creating df with top 10 tv shows producing countries and average difference between release year and added year
tv_year = df1[(df1['type'] == 'TV Show') & (df1['country'].isin(df_tv['country']))]

#adding the difference column
tv_year['diff'] = tv_year['year_added'] - tv_year['release_year']

#calculating the average diff
tv_year = tv_year.groupby('country')['diff'].mean().round().reset_index().sort_values(by = 'diff',ascending = False)

#converting to int
tv_year['diff'] = tv_year['diff'].astype('int')

tv_year

#creating y-axis co-ordinates
yrange = range(1,len(tv_year)+1)
xrange = [0 for i in range(10)]

#setting the plot style
fig, ax = plt.subplots(figsize=(8, 7))


#plotting the scatter points
ax.scatter(xrange,yrange,color = '#21134D',s=100,label = 'TV Show Release')
ax.scatter(tv_year['diff'],yrange,color = '#F5921B',s=100,label = 'TV Show Added')

#plotting the horizontal lines between the points
ax.hlines(yrange,xmin = 0,xmax = tv_year['diff'],color = 'grey',alpha = 0.4,label = 'Average Difference')

#adding avg. difference values on lines
for i in range(10):
    ax.text(tv_year['diff'].iloc[i]/2,yrange[i]+0.2,f"{tv_year['diff'].iloc[i]} years",
            {'font':'serif', 'size':9,'fontweight':'light'},ha = 'center',va = 'center')

#removing the axislines
for s in ['top', 'left', 'right', 'bottom']:
    ax.spines[s].set_visible(False)

#removing tick marks but keeping the labels
ax.tick_params(axis = 'both',length = 0)

#customizing the y-axis labels
ax.set_yticks(yrange,tv_year['country'],fontsize= 12,fontfamily='serif',fontweight = 'bold')

#adding xlabel
ax.set_xlabel('Difference in Years',fontfamily='serif',fontsize = 11,fontweight = 'bold')

#Adding title to the graph
ax.set_title('How old are the TV Shows?',{'font':'serif', 'size':15,'weight':'bold'})

#adding legend
plt.legend(loc = (0.8,0.83))


plt.show()

"""**ðŸ” Insights**


 * In general, there seems to be a trend of adding movies to Netflix with a longer delay compared to TV shows. This could indicate that viewers might have a higher demand for recent TV shows than movies.


 * Spain has the lowest delay for movies (2 years) and TV shows (1 year), which could suggest that Spanish viewers have a preference for more recent content.

 * Countries like India, UK,USA and France have in general more delay in movies (8 to 6 years) and very less delay in TV Shows (1 to 3 years) indicating preference for recent TV shows and older movies in these countries.

* Japan has a consistent delay (5 to 6 years) in both Movies and TV Shows.

# Recommendations

* The data suggests that catering to local preferences is crucial for success. Netflix should continue to invest in producing content that resonates with different cultural and linguistic preferences around the world.

* Given the significant investment in content production in the USA and the emphasis on India, Netflix should continue to focus on these markets.
"""